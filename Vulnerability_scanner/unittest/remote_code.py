import unittest
import re
from unittest.mock import patch
from Main import test_remote_code_execution

class TestRemoteCodeExecution(unittest.TestCase):

    @patch('Main.requests.get')
    def test_method_1_vulnerable(self, mock_get):
        mock_get.return_value.text = 'RCE_SUCCESS'
        url = 'http://example.com'
        payloads = ['payload1', 'payload2']
        method = '1'
        expected_output = ['Payload: payload1 - Remote Code Execution FOUND! (Method 1)',
                           'Payload: payload2 - Remote Code Execution FOUND! (Method 1)']

        with patch('builtins.print') as mock_print:
            test_remote_code_execution(url, payloads, method)
            actual_output = [re.sub(r'\x1b\[\d+m', '', args[0]) for args, _ in mock_print.call_args_list]

        self.assertEqual(actual_output, expected_output)

    @patch('Main.requests.get')
    def test_method_1_not_vulnerable(self, mock_get):
        mock_get.return_value.text = 'Some other response'
        url = 'http://example.com'
        payloads = ['payload1', 'payload2']
        method = '1'
        expected_output = ['Payload: payload1 - Not Vulnerable (Method 1)',
                           'Payload: payload2 - Not Vulnerable (Method 1)']

        with patch('builtins.print') as mock_print:
            test_remote_code_execution(url, payloads, method)
            actual_output = [re.sub(r'\x1b\[\d+m', '', args[0]) for args, _ in mock_print.call_args_list]

        self.assertEqual(actual_output, expected_output)

    @patch('Main.requests.post')
    def test_method_2_vulnerable(self, mock_post):
        mock_post.return_value.text = 'RCE_SUCCESS'
        url = 'http://example.com'
        payloads = ['payload1', 'payload2']
        method = '2'
        expected_output = ['Payload: payload1 - Remote Code Execution FOUND! (Method 2)',
                           'Payload: payload2 - Remote Code Execution FOUND! (Method 2)']

        with patch('builtins.print') as mock_print:
            test_remote_code_execution(url, payloads, method)
            actual_output = [re.sub(r'\x1b\[\d+m', '', args[0]) for args, _ in mock_print.call_args_list]

        self.assertEqual(actual_output, expected_output)

    @patch('Main.requests.post')
    def test_method_2_not_vulnerable(self, mock_post):
        mock_post.return_value.text = 'Some other response'
        url = 'http://example.com'
        payloads = ['payload1', 'payload2']
        method = '2'
        expected_output = ['Payload: payload1 - Not Vulnerable (Method 2)',
                           'Payload: payload2 - Not Vulnerable (Method 2)']

        with patch('builtins.print') as mock_print:
            test_remote_code_execution(url, payloads, method)
            actual_output = [re.sub(r'\x1b\[\d+m', '', args[0]) for args, _ in mock_print.call_args_list]

        self.assertEqual(actual_output, expected_output)

    def test_invalid_method(self):
        url = 'http://example.com'
        payloads = ['payload1', 'payload2']
        method = '3'
        expected_output = 'Invalid RCE method. Please enter either \'1\' or \'2\'.'

        with patch('builtins.print') as mock_print:
            test_remote_code_execution(url, payloads, method)
            actual_output = re.sub(r'\x1b\[\d+m', '', mock_print.call_args[0][0])

        self.assertEqual(actual_output, expected_output)

if __name__ == '__main__':
    unittest.main()
