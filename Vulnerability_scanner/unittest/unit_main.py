import unittest
from unittest.mock import patch, MagicMock
import io
import sys
import builtins
from Main import main, test_reflected_xss_payloads, test_dom_based_xss_payloads, test_sql_injection_payloads, \
    test_remote_code_execution, test_server_side_template_injection, test_open_redirection_payloads, test_clickjacking


class TestVulnScanX(unittest.TestCase):
    @patch('builtins.input', side_effect=['1', 'http://example.com', '9'])
    @patch('builtins.open', side_effect=[open('Payloads/PayloadXSS.txt', 'r'), open('Payloads/PayloadSQL.txt', 'r'),
                                         open('Payloads/PayloadRCE.txt', 'r'), open('Payloads/PayloadSSTI.txt', 'r'),
                                         open('Payloads/PayloadOpenRed.txt', 'r')])
    def test_main(self, mock_open, mock_input):
        # Redirect stdout to capture print statements
        captured_output = io.StringIO()
        sys.stdout = captured_output

        # Call main function
        main()

        # Reset redirection
        sys.stdout = sys.__stdout__

        # Check if expected outputs are present in captured output
        self.assertIn("Exiting VulnScanX. Goodbye!", captured_output.getvalue())

    @patch('requests.post')
    def test_reflected_xss_payloads(self, mock_post):
        mock_post.return_value.text = 'XSS'
        url = 'http://example.com'
        payloads = ['<script>alert(1)</script>']

        with patch('builtins.print') as mocked_print:
            test_reflected_xss_payloads(url, payloads)
            mocked_print.assert_called_with(f"URL: {url} - Payload: {payloads[0]} - XSS Found(via requests)")

    # Similarly, write tests for other functions...

if __name__ == '__main__':
    unittest.main()
